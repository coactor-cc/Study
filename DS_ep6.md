# sort 
## 评价指标
时间复杂度  
空间复杂度  
**稳定性**：序列中关键字相同元素的**位序在排序前后是否改变**
## 分类
内部排序
外部排序
## 插入排序
是一种原地排序
取出元素→查找在有序表中位置→插入有序表
### 直接插入排序
利用m[0]进行插排，利用外部存储空间进行插排
查找位置方式为顺序查找
### 折半插入排序
利用m[0]进行插排，利用外部存储空间进行插排
查找位置方式为二分查找
## 希尔排序
相距为d的元素作为子表进行直接插排→对整个表进行直接插排  
只能用于顺序表  
### 分析序列过程
## 冒泡排序
每一趟比较把最小|最大的移到最前|最后面
### 提前结束问题
若一趟没有发生任何交换
### 性能分析
以交换次数衡量其时间复杂度
## 快速排序
`不稳定`  
输入 low high A
一趟，用枢轴元素将表劈成两半：  
结束条件low=high 把基准元素放进去  
然后迭代执行算法 看来得设置出口
### 性能分析
stack frame 就麻烦了
用了递归调用栈帧换时间
$$
n\log_2 n
$$
### 优化
枢轴选取好

## 简单选择排序
扫描→交换
事件复杂度不会变，`执行过程与序列无关`
>对比插入排序
不稳定的
## 堆排序
1.建堆2.调整
### 堆
#### 堆的插入和删除
#### 堆的调整
堆本身是一种递归定义的的数据结构-二叉树本身也是递归定义的数据结构
属于选择排序的一种
利用堆这种数据结果进行排序
哈哈哈哈哈哈，那不是一直pop就完事啦？？
是一颗顺序存储的完二叉树
大根堆和小根堆
so easy
>并不是利用辅助堆进行外部排序，而是类堆算法进行原地排序

1轮：从下到上
2轮：从上到下
举反例证明不稳定
## 归并排序
空间复杂度o(n)
时间复杂度o(nlog n)
## 基数排序
利用key=int 进行位数排序
需要一个数组列表
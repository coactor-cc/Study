# 指令系统
设计指令系统——计算机体系结构
指令系统实现——计算机组成
def （机器）指令：硬件能够识别和执行的命令  
def 指令系统：所有机器指令的集合
X86|ARM架构
## 指令系统组成
### 指令功能
【操作OP】干什么+【操作数OPD】对谁
#### 操作
##### 数据传送|I/O
##### 算逻运算及位移运算
##### 转移控制
##### 其他（浮点、十进制、CPU控制）
### **指令格式**
操作码+地址码
#### 操作码
##### 包含信息
- 操作类型
    - 操作OP
    - 操作数类型OPD type
- 格式信息
    - 地址码个数
    - 目的操作数地址位置
   
d 指定REG 用于 目的(d= 1)还是源 (d 一0)  
##### 定长操作码
译码电路简单、**平均码长**（指平均操作码长）最长
##### **变长操作码——扩展编码** （**编程实现**）
将哈夫曼编码扩展成几种长度的编码  
译码复杂、规整性差，平均操作码长短
#### 地址码
**寻址方式位F+地址参数**
指令的各个操作数地址、下条指令地址
零地址、单地址、双地址
#### 指令字长
一条指令所占二进制**信息**的位数  
操作码长度，地址码个数，各个地址码长度
必须是主存单元的整数倍，但按机器字长划分：半字长|单|双->针对机器字长来说

---
来自chartGPT  
指令字长按照机器字长进行分类主要是因为指令的长度需要与计算机的底层硬件结构相匹配，以确保指令能够被正确解析和执行。

机器字长是计算机处理器一次能够处理的二进制位数，也是计算机内部数据传输和处理的基本单位。常见的机器字长包括8位、16位、32位和64位。不同的机器字长决定了计算机的寻址能力、数据处理能力和存储能力。

指令字长与机器字长的关系在于，指令的长度必须与机器字长匹配，以便被处理器正确地解析和执行。指令字长为机器字长的整数倍时，可以更高效地使用计算机的硬件资源和机器级指令集。而指令字长不为机器字长的整数倍时，则可能需要额外的解析和处理步骤，会增加计算机的复杂度和开销。

因此，为了充分利用计算机硬件资源并提高执行效率，指令字长通常会按照机器字长进行分类，并与底层硬件结构相匹配。这样可以保证指令能够以最快速度被解析和执行，提高计算机的性能和效率。
##### 定长指令字结构
所有指令的指令字长都相等  
结构简单，格式规整
##### 变长指令字结构
灵活性好，结构复杂
#### 性能指标
##### 规整性 
操作码长度是否相等  
地址码格式是否一致  
目的操作数位置是否固定  
##### 平均码长
平均码长：程序中所有**指令字长**的平均值
任书在eg中偷换概念，求了指令操作码的平均码长  
故我理解的平均码长：一个编码集合（操作码、指令、ASCII、GB2312、int）的平均所占2进制信息位数   
只不过大部分编码集合的各个元素对应的码长相等而已
## 操作数存放方式
### 寄存器
寄存器长度=机器字长  
按实际个数编址（eg'IA32 8通用寄存器，000-111）寄存器地址=存储器编号   
不同长度数据存放在寄存器中都**用寄存器地址表示数据地址 **
### 存储器
端序：大端（IBM），小端（Intel）
对齐：对齐：数据地址低位给0（根据数据长度）——边界对齐  
对齐可以确保访问性能  
数据在存储器中用逻辑地址（虚拟主存地址）表示数据地址
## 寻址方式
### 定义
通过地址码获得部件地址的方法  
通过地址码形成操作数地址或指令地址的方法  

**寻址方式的识别在译码阶段完成
寻址方式的实现在执行阶段完成**

---
部件（如存储器）地址较长，想用较短地址表示部件地址  
程序的逻辑地址空间很大（个人：会分配为机器字长），存储单元地址（一般按字节编址）很长，为缩短指令字长，对操作数地址进行地址变换（形式->有效的映射）
### **约定**
Intel 80x86
寄存器地址——Rx   
寄存器内容——(Rx)  
形式地址——A 
存储单元内容——M[A] 

操作数地址&OPD=寄存器地址Rx|有效地址EA  
地址参数=A+Ri
 
指令功能目的操作数←源操作数 OP 源操作数   
目的操作数为目标地址  
源操作数为操作内容  

指令中形成的存储单元地址（逻辑地址|段内地址）——有效地址——EA  
程序不分段时，有效地址＝逻辑地址  
程序分段时，有效地址＝段内地址  
地址码中映射存储器的地址——形式地址——A  
形式地址A<有效地址EA  

### 指令寻址（PC或控制流语句）
顺序型：EA=(PC)+"1" 隐含寻址⑨
1为当前指令所占存储单元个数（由操作码给出）  
跳跃型：直接③->找PC或者相对⑧->相对PC的偏移
用一个地址码存放下一条指令地址，通常都是最后那个
### 寻址方式——8+1
#### 立即寻址①
不需要取操作数，写死在指令中，一起读入指令寄存器  
地址参数=Imme
#### 寄存器寻址②  
地址参数=Ri   
&OPD=Ri 
OPD=(Ri)
#### 直接寻址③——没有节约码长   
地址参数=A  
&OPD=A  
OPD=M[A]
#### 间接寻址④——没优化到吖  
地址参数=A  
&OPD=M[A] 
OPD=M[M[A]]
#### 寄存器间接寻址⑤
地址参数=Ri  
&OPD=(Ri)  
OPD=M[(Ri)]  
#### 变址寻址⑥   
地址参数=Ri+A  -仅有一个变址寄存器可省略   
&OPD=(Ri)+A  (Ri)作为变址值 A作为基地址（逻辑地址）  
OPD=M[(Ri)+A]  
数组访问
PC顺序访问指令顺序寻址
```
array=new int[5];
print(array)
```
#### 基址寻址⑦
地址参数=Ri+A -仅有一个基址寄存器可省略   
&OPD=(Ri)+A  
OPD=M[(Ri)+A]   
程序重定位
```
data sagement
int x
```
> 变址和基址的区别，程序员在写汇编指令的时候REG只需要指明名字，而A要显式写出，叫你写出数组首地址可能么，可以，数组名，叫你直接写出程序段首地址，不如把他放在一个寄存器里
#### 相对寻址⑧
其实和就是**特殊**的基址寻址  
1.只能用于指令寻址  
2.基地址固定为PC  
地址参数=A-**有符号数**（PC隐含）  
&OP=(PC)+A  
OP=M(PC+A)  
#### 隐含寻址⑨
无地址码 当然也不用标寻址类型，隐含约定下一个OP|OPD地址
顺序形指令的指令寻址都是隐含寻址，
LOOP的循环变量OPD隐含CX中
#### **指令格式分析与应用**重中之重，必须拿下
Demo_IS
## ~~指令系统举例~~ 
### MIPS
### Pentium
## 指令系统发展（基本概念）**背**
### CISC复杂指令系统计算机
#### 目的
侧重增强指令功能，以减少程序中的指令数($I_N$)
#### eg
IA16(117+16)→IA32(+40+3+SSE)→IA64(+EM64T)→
 SSE—MMX(57)、SSE(+70)、SSE2(+144)、SSE3(+12)、SSE4(+50)
#### 特征
·采用变长指令字结构，指令种类多、格式复杂、寻址方式多  
·大多为REG-MEM型指令，执行时间较长(几个～几十个TC)  
·指令功能复杂、悬殊大，编译程序复杂，执行控制复杂，不利于流水等技术

### RISC精简指令系统计算机
#### 目的
侧重简化指令功能，以提高指令执行速度(CPI)
#### eg
RISC 1有31条指令、78个寄存器
MIPS16有31条指令(MIPS32为150多条)、32个寄存器
#### 特征
·采用定长指令字结构，指令种类少、格式简单、寻址方式少  
·除Load/Store外，都是REG-REG型指令(执行速度快[=1TC])  
·使用大量寄存器，便于编译优化、过程调用的快速实现  
·执行控制简单，有利于流水、并行处理技术

# 进程管理
## 预备——如何高效管理和使用CPU
人们在使用CPU的实践中提出了同时出发、交替执行`并发`机制，有了多进程策略，在实现的过程中引出了一系列问题，由此形成了操作系统

程序：外存中的可执行文件  
装载：双击|命令行

### 如何使用CPU
#### 1无添加
设完PC初值自己动！  
问题：响应慢、CPU利用率太低
#### 并发机制
多道程序切换才能提高利用率  
并发，同时出发，交替执行    
问题1：程序之间如何实现切换(切出、返回)？

只是修改PC是不行的，需要额外记录现场   
e.g.看书，+书签+头脑中的场景(现场)  

需要有个概念来刻画运行中的程序——进程

问题2：切出去选谁？(调度问题)
调度：切换选谁，利用调度算法实现

问题3：共享数据冲突？(同步问题、互斥问题)
交替执行时，放在共享区域的count含义如何确保正确？
核心在于进程同步，保证`合理的推进顺序`

交替执行时：我在使用打印机的时候如何确保打印到一半不被别人拿去打印其他东西？

内核态和用户态通过硬件标志DPL、CPL隔离
内核态进程1访问到了内核态进程2怎么办；
用户态进程1访问到了用户态进程2的地址怎么办，通过内存映射表解决

问题4：如何凑齐七龙珠(死锁问题)
## 进程
为了实现程序并发执行，对程序进行控制和划分的概念
### 概念
通俗：执行中的程序  
是进程实体`程序`的运行过程，是系统进行资源**分配**和**调度** 的独立单位   
*若内核支持线程，则线程*为调度独立单位  
组成：PCB+程序+数据
>考点【中】进程理解

### 进程控制块PCB
pid   
进程状态标记  
中断相关：断点及程序状态`PC、PSW`*这部分其实通常用硬件维护*、现场`GPRs`(包括了函数调用栈指针、中断屏蔽字等)   
调度相关：优先级
内存管理相关：进程内存边界、**页表段表地址**  
I/O管理相关：打开文件列表、给进程分配的I/O设备表  
记账信息：占用的资源等，网络传输带宽等  
TODO 补充

### 进程状态
>考点【易】状态转换
#### 进程创建和终止
>考点【易】对fork()执行过程进行分析应用
##### fork()
进程执行fork()时，会创建一个子进程，两个进程继续并发执行fork()后的指令`如果不wait()的话`   
父进程fork()的返回值为`子进程pid`，  
子进程返回值为`0`；  
##### wait()
调用加入wait队列
##### exit()
可用父进程终止子进程

### ~~进程通信~~
独立进程：一个进程不能被其他进程所影响  
协作进程：一个进程能被其他进程所影响  

进程协作的目的：
信息共享、提高运算速度、模块化、方便

进程间通信机制(IPC)

>考点【易】进程通信的方式和基本特点
#### 共享内存
建立一块协作进程共享的内存区域

用`共享内存+同步(冲突处理)` 解决生产者-消费者问题  
共享一个buffer无限缓冲|有限缓冲`循环队列`  
但是没有解决访问冲突问题-见进程同步  
#### 消息传递
常用于分布式环境  
需要通信线路+协议
不需要解决冲突，交换少量数据  
利用**系统调用**send()，receive()实现
#### 管道-Linux
实质还是一种共享内存，只不过不用你写地址，封装了部分功能进入操作系统
一对特殊的文件单项文件，双方都能访问，单项

## 线程
### 概念
共享代码和数据、只改变运行的信息，运行`不改变资源的需求`
>考点【易】线程与进程的区别 
### 多线程模型
>考点【易】线程阻塞的问题简单分析
#### 用户线程  
编程语言库提供的，利用编程机制实现切换的线程
#### 内核线程
在内核态操作系统支持的线程
#### 多对1|用户级
任1时刻只能有一个线程访问内核，一个发生系统调用阻塞全部阻塞*如浏览器一个标签卡全卡了*  
切换在用户态实现
#### 1对1|内核级
创建内核线程的开销会影响应用程序性能
#### 多对多|用户+内核级
代码逻辑→运行机会的映射

|  | 用户级 | 核心级 | 用户+核心级 |
|---|---|---|---|
| 实现模型 | 多-1 | 1-1 | n-m |
| 利用多核 | 差 | 好 | 好 |
| 并发度 | 低 | 高 | 高 |
| 代价 | 小 | 大 | 中 |
| 内核改动 | 无 | 大 | 大 |
| 用户灵活性 | 大 | 小 | 大 |

### ~~用户级线程的切换~~
实现：需要用TCB维护各自的函数调用栈,切换时压栈保存
```
create()  
yeild()  
{
    切换TCB读取esp切换用户栈
}  
```
### ~~内核级线程切换~~
一个内核级线程就要一套栈【用户栈+内核栈】  
要实现线程切换那就要多套了，套栈：既要在用户态跑，也要在内核态跑 
```
schedule()
{
    1.INT 0x80;//发起中断 
    2.进入内核栈
    还要压入用户栈的现场
    相当与把用户栈的活动记入往内核栈压，能pop回去
    3.内核栈切换

        switch_to{
            找到下个线程TCB;
            找到内核栈esp;\\其实和yeild一样
        }

    4.IRET目标内核线程弹出了：
    5.返回目标用户恢复现场
    //RET指令时不恢复现场是不可恢复中断用的
}
```
## CPU调度
### 基本概念
选择可用的进程切换执行  
给PC及其工作的这一套系统CPU给他分配一个需要执行的指令序列  
利用队列的链式实现将PCB串起来  
利用调度程序控制它执行 
#### CPU调度程序
### ~~调度层次~~
高级调度|作业调度   
创建PCB  
中级调度：调出外存但PCB不销毁、调入内存  
低级调度|进程调度|CPU调度  

### 时机、切换与过程
#### 时机
1。运行→等待  
2。运行→就绪  
3。等待→就绪  
4。终止  
**不能调度**  
中断处理过程中   
操作系统内核临界区中  
原子操作过程中  
#### 切换
一个进程让出处理机，让另一个进程占用处理机的过程   
见上文线程切换   
**分派程序**  
1切换上下文2.切换到用户态3.跳转
### 准则
CPU使用率  
周转时间：完成时间-提交时间  
带权周转时间=周转时间/execute时间≥1  
等待时间 在就绪队列等待的时间`调度算法影响的核心`    
~~响应时间~~ 用户提交请求到产生响应  

>考点：平均周转时间、平均等待时间
### 方式
见上时机，只允许1.4发生的是非抢占式，其余为抢占式
### 调度策略与甘特图
#### FCFS
非抢占   
平均等待时间通常较长

护航效应：I/O型进程等待一个CPU约束进程释放CPU，导致CPU和设备使用率变低
#### SJF
抢占`最短剩余时间优先`|非抢占   
平均等待时间最小，无法在短程调度中实现   
若要对进程进行CPU区间和I/O区间划分的话，SJF检测的是下一个CPU区间的长度
#### PSA
抢占|非抢占   
无穷阻塞|饥饿
老化技术：高响应比优先
#### RR
抢占
周转时间随时间片的大小增加`可能增加|可能降低`
>考点：上下文切换次数
#### ~~多级队列~~
进程被`永久地分配到一个就绪队列`，队列内，独立调度，队列间，优先级或分时
#### 多级反馈队列
设置多级队列，`允许进程在队列间移动`，每个就绪队列都有独立的调度算法，队列间固定优先级抢占
>允许移动体现了一种老化策略，可以阻止饥饿发生

e.g. 三级队列【前两级用RR|8ms→16ms→32ms，最后一级用FCFS】  
new PCB→队列0→
执行一次看看你是不是符合要求，不符合丢下去，长作业下沉
#### 多处理器调度
多个CPU：非对称多处理|对称多处理  

处理器亲和性：努力使同一进程在同一处理器上运行(软亲和|硬亲和)
## 互斥与同步
协作进程的`合理有序`推进，而进程之间又完全不知道对方的存在，自然地引出了信号，但是从信号→信号量是一个进步
### 概念
汤书  
协作进程的制约关系   
1.程序先后执行顺序冲突*直接制约关系*  
2.使用系统资源的冲突*间接制约关系*  
临界资源：一个时间段内只能供一个进程使用的资源
进程同步：执行顺序  
互斥：对临界资源的互斥访问  
进入区 临界区 退出区 剩余区  

邓书  
共享逻辑地址空间导致的访问冲突`如果采用通道或消息传递就不会有这种问题`
本章就是讨论各种方式，以确保共享同一逻辑地址空间的协作进程可以有序的执行  

个人认为邓书更合理，因为设备CPU等资源在进程调度模块就已经解决了，你只有活动了资源才能就绪  

#### 同步
竞争条件(race condition)：程序并发访问同一数据，且执行结果与访问发生的特定顺序有关  

进程同步：一定程度限制协作进程间执行顺序，以避免竞争条件出现的措施  
 
#### 临界区问题
进入区：实现对临界区的进入请求  
临界区：每个进程有一段代码叫临界区  
在这个区域中的语句可能会**修改**`共享的数据`【变量，表，文件】  
退出区  
剩余区

操作系统内临界区的处理：
抢占内核和非抢占内核
### ~~软硬件机制互斥~~
### 信号量机制
实现协作的用户进程的同步和互斥提供的系统调用
>大题，利用PV解决实际问题
#### 信号量+PV操作
系统调用wait()→P()、signal()→V()

信号量被不正确地用来解决临界区问题时，会导致各种错误
#### 计数信号量S
有若干个实例，若干份资源
#### 二进制信号量|互斥锁mutex
只有一份实例，实现互斥访问

>互斥性并不是原子性，用户进程通过互斥锁进入临界区后，依然会被操作系统调度，只不过其他拥有该锁的进程遇到互斥锁时会因不能进入而阻塞

##### 整型信号量|自旋锁
系统维护一个int，先判断再修改导致其不可能为负值   
这种解决方案显然`会忙等` 
>对于单核直接就进入了死循环，对于多核相当于一个用户进程自旋

```c++
int S
wait(S){
while(S<=0)
;
S--;
}
Signal(S){
    S++;
}  
```

##### 记录型信号量`semaphore`
系统维护int+阻塞队列+block()，wakeup()  
它不再是一个单纯的count，而是一个struct的解决方案  
没有完全解决忙等，将用户去临界区问题转化到内核区  
取消了用户区的忙等，将忙等限制在wait()、signal()临界区内  
这些区比较短，几乎不会出现占用(争夺)
```python
S=(value,list)

Wait(S):
    S.value--
    if(S.value<0):
        block()

Signal(S):
    S.value++
    if(S<=0):
        wakeup(s.list)
}：
```
##### 实现进程互斥
```python
semaphore mutex=1
process:
    P(mutex)
    互斥操作
    V(mutex)
```
##### 实现进程前驱后继
初值0，后继进程操作之前P操作，前驱进程操作之后v操作，前P后V
```python
semaphore p1=0
Process1():
    exeu()
    signal(p1)

Process2()
    wait(p1)
    exeu()
```
#### PV操作的实现
信号量的实现在于保证对信号量操作的`原子性`,在单CPU情况下，利用进入内核态进行`关中断`实现  
### 经典同步问题
#### 生产者-消费者问题|有限缓冲问题
问题描述：  
共享固定大小缓冲区的两个线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题  

约束条件：  
(1)队列满不能生产  
(2)队列空不能消费  
(3)不能同时生产消费  
```python
semaphore empty=0
semaphore full=buffersize
semaphore mutex=1
comsumer():
    while 1:
        wait(empty)
        wait(mutex)
        comsume()
        signal(mutex)
        signal(empty)

producer():
    while 1:
        wait(full)
        wait(mutex)
        produce()
        signal(mutex)
        signal(empty)
```
多类型数据共用有限缓冲问题√ 
TODO 多生产者消费者问题  
#### 读者写者问题
单一限制型多对多模型
问题描述：  
一个数据可以被多个进程共享，我们把只读该文件的进程称为“读者进程”，其他进程为“写者进程”。允许多个进程同时读一个共享对象，但不允许一个写者进程和其他写者进程或读者进程同时访问共享对象。  

约束条件：  
(1)只允许一个写者进程    
(2)写者进程写操作之前不允许存在其他进程  
(3)必须允许多个读进程共同读文件



思路：利用count来实现读者直接头P尾V
```c++
semaphore rw=1
int count =0
semaphore mutex=1

semaphore W=1//解决写者饥饿问题,先来先服务

Writer(){
    while(1):
        P(W)
            P(rw);

        write();

            V(rw);
        V(W)
}
Reader(){
    while(1):
        P(W)
            P(mutex);
                if(count==0)
                    P(rw);
                count++;
            V(mutex);
        V(W)

        read();

        P(mutex);
            count--;
            if(count==0)
                V(rw);
        V(mutex);    
}
```
#### 哲学家进餐问题
`并发控制问题` 

问题描述：  
有五个哲学家，他们的生活方式是交替地进行思考和进餐，哲学家们共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五支筷子`互斥`，平时哲学家进行思考，饥饿时便试图取其左、右最靠近他的筷子，只有在他拿到两支筷子时才能进餐，该哲学家进餐完毕后，放下左右两只筷子又继续思考。

约束条件：  
(1)只有拿到两只筷子时，哲学家才能吃饭`潜在循环等待`。  
(2)如果筷子已被别人拿走，则必须等别人吃完之后才能拿到筷子`非抢占`。  
(3)任一哲学家在自己未拿到两只筷子吃完饭前，不会放下手中已经拿到的筷子`请求和保持`。

`数组型信号量的使用`

**解1**  
最多允许4个哲学家吃饭  


评价：这是一种基于具体情景设计的解决方案，并不具有普适性，只能在n个进程都只请求2种资源，且满足单环互斥的情景`好用啊最优解`

**解2** 
非对称解决方法  
评价：没看到背后抽象出的模型

**解3** `信号量的一个解`  
保证拿筷子动作的互斥性(必须在临界区拿起两只筷子)
```c++
semaphore chopsticks[5]={1,1,1,1,1};
semaphore mutex = 1;
phylosopher(){
    P(mutex);
        P(chopsticks[i]);
        P(chopsticks[(i+1)%5]);
    V(mutex);
    ...
    V(chopsticks[i]);
    V(chopsticks[(i+1)%5]);
    ...
}
```
评价：不能解决`饥饿问题`,不能`最大限度`使最多的哲学家同时吃饭


## 死锁
各个进程等待对方手里的资源，导致阻塞都无法向前推进的现象 

某个进程申请的资源被其他等待进程占有，该等待进程可能再也无法改变状态
### 原因
竞争不可抢占资源  
进程推进非法  
信号量使用不当——信号量作为一种资源
### 必要条件
1. 互斥条件：存在互斥资源
2. 非抢占：你旧把资源握手里吧
3. 请求和保持|占有和等待：在保持资源的同时请求
4. 循环等待`有循环等待链，但说不定有外部解决方案`
### 解决方法
>其实现在操作系统采用的基本是忽略的策略，重启
#### 预防死锁
##### 用SPOOLing技术-互斥条件  
适用场景有限，这个条件**一般不能被破坏**
##### 抢占-非抢占
，
抢夺会导致别人工作无效，同时增加系统开销
##### 静态分配|阻塞释放-请求和保持
资源利用率降低了，增加饥饿可能性
释放会增加饥饿可能性
##### 资源分配按序进行-循环等待
资源顺序链法
1不方便添加设备
2使用顺序和编号顺序不一致导致资源浪费
3编程复杂
#### 避免死锁
有趣的例子  
手握100e,企业B，A，T找你借钱，你的余额公开，当你被发现借不出钱，他们就不会还钱→gg
|  | 最大需求 | 已借 | 还会借 |
|---|---|---|---|
| B | 70 | 20 | 50 |
| A | 40 | 10 | 30 |
| T | 50 | 30 | 20 |

##### `银行家算法`
时间复杂度：$mN^{2}$n为资源数，m为进程数  
采取预先声明资源策略，预先声明所有资源，系统利用全局信息有选择的分配资源，而不是满足条件就分配  
1. 检测规范性if Request≤Need  
2. 检测可分配性if Availble≥Request  
3. 试探分配安全性 Availble-=Request，执行安全性算法

```python
Scurity():
for k in PList.lenth:
    flag=0
    for i in PList:
        if Avaible>=i.Need:
            Avaible+=i.Allocation
            PList.remove(i)
            flag=1
            break
    if flag==0:
        return fail
return ture
```
Availble=(1,2,1) Request(x,y,z)
| 进程 | Max | Allocation | Need |
|---|---|---|---|
| P1 | (7,5,3) | (2,2,1) | (7,4,3) |
| P1 | (3,2,2) | (2,0,0) | (1,2,2) |
| P2 | (9,0,2) | (3,0,2) | (6,0,0) |
| P3 | (2,2,2) | (2,1,1) | (0,1,1) |
| P4 | (4,3,3) | (0,0,2) | (4,3,1) |

#### 检测+解除
化简资源分配图
剥夺资源，撤销进程，历史回退
#### 死锁忽略
代价最小 预防不容易编程实现，或者静态分配降低资源利用率，避免降低性能，检测回滚难以实现
#### 资源分配图
P节点-进程节点；R节点-资源节点【单个资源+单个资源】
请求边、分配边

可能三：进程实际需要的最大资源小于声明的最大需求资源。

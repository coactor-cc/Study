# 内存管理
1. 内存空间分配与回收
2. 内存空间扩展
3. 地址转换
4. 存储保护
## 内存管理基础
### 逻辑地址与物理地址
#### 逻辑地址
程序的编址B和编址空间4T——给巨大
#### 物理地址
主存的编址B和编址空间32/64-机器字长绝定
### 程序的装入和链接
#### 程序的装入（装入内存，逻辑地址到物理地址转换）
- 绝对装入方式（老旧——单道程序环境）
- 可重定位装入方式（目标模块地址0，装入时修改）
- 动态运行时的装入方式（执行时修改）
#### 程序的链接
- 静态链接（装入前链接）
- 装入时动态链接（边装入边链接）
- 运行时动态链接（装入后执行链接）
### 内存保护（待补充）
使进程只能访问自己的内存空间，
#### 法1：设置一对上下限寄存器
#### 法2：重定位寄存器（基址寄存器）+界地址寄存器（限长寄存器）
## 连续分配管理方式（分区）
系统为用户进程分配的必须是一个连续的存储空间
### 单一连续分配(不重要)
分系统区和用户区，单道用户程序
### 固定分区分配（内部碎片）
将用户区划分为若干固定大小的分区
#### 内部碎片
分配给某些进程的内存区域中，有些部分没有用上
#### 分区说明表**编程实现**
![Alt text](OS/images/image.png)
### 动态分区分配（可变分区分配）
1. 数据结构
2. 分配算法
3. 分配与回收操作
#### 外部碎片
内存中的某些空闲分区由于太小而难以利用  
紧凑（拼凑，compaction）开销
#### 空闲分区表**编程实现**
#### 空闲链**编程实现**双向链表
#### **分区分配与回收**编程实现
回收时需要合并相邻空闲分区
#### 动态分区分配算法（下次看）
## 非连续分配管理方式（分页）
### 分页存储管理
#### 概念
##### 页框/页帧/主存-辅存层次的块/物理块 page frame
主存空间划分成的若干大小相等的区域通常为4KB-$2^12B$这东西比字节大多了
> 这是内存分配时的特殊编址方式，而非程序访问时的编址方式——自我解释
##### 页/页面
进程的逻辑地址空间按页编址（扯淡）只是按页编写页号 逻辑地址=页号+页内偏移量 物理地址=块号+块内偏移量
> 程序的逻辑地址空间（任国林）由于程序需要装入主存才可以执行，（主存通常按字节编址），故程序的存储单元长度必须和主存相同，即采用字节编写逻辑地址，  
> 而程序通常分段，故用段号+段内地址，附以程序头（各段的在程序中的相对位置和段长）——以文件形式存放
##### 页表（数据结构）-存放在PCB中-PCB还放基址**编程实现**
页号不占存储空间，块号占整数个字节B  
页表项（逻辑）=页号+块号  
页表项（物理实现）=块号
页表项长度——最小长度，实际长度（可能会使一个页框能存放整数个页表项）
#### 基本分页地址变换机构
页表寄存器PTR页表起始地址F，页表长度M——由PCB获得
>PCB放在系统区  

两次访存操作
![Alt text](OS/images/image-14.png)
#### 具有块表的地址变换机构
快表（联想寄存器）TLB 页表缓存
![Alt text](OS/images/image-15.png)  
最后一步是拼接
#### 多级页表
将页号进行拆分，外层页表以高位页号为索引查找低位页号->解决连续分配问题  
在装入时装入外层页表（页目录表），在需要时装入内层页表->解决内存空间占用问题  
多级页表时各级页表不能占用超过一个页的大小  
访存次数分析：N+1次访存
### 分段存储管理
以段为单位分配内存，满足用户在编程和使用上的需要  
逻辑地址=段号+段内地址  
#### **段表**数据结构
指令：段名+段内地址（助记符）方便程序员进行内存管理  
段表项（逻辑）=段号+段长+基地址（段首地址）
段表项（物理）=段长+基地址  
段表项长度=最大段内地址空间+主存地址空间->取整B
#### 地址变换机构
![Alt text](OS/images/image-16.png)
要对段内地址进行检查是否越界  
最后一步是做偏移
#### 分页、分段对比
1. 分页是信息物理单位，为提高内存利用率，分段信息逻辑单位，为满足用户需要
2. 页的大小固定，由系统决定，段的大小不固定，根据信息性质划分
3. 分页用户地址空间1维（助记符），分段用户地址空间二维（段名+段内地址）
### 信息共享和保护
### 段页式存储管理
逻辑地址=段号+页号+页内地址
#### 数据结构
段表（物理）=页表长度+页表首地址（块号？？）  
由于分页了，所以页表也肯定是从主存块首地址开始存的，偏移量全0不用记录了  
页表（物理）=块号
#### 地址变换机构
![Alt text](OS/images/image-17.png)
## 虚拟内存管理（内存空间扩展）
### 传统存储管理方式的特征
1. 一次性
2. 驻留性
### 覆盖技术
程序分段，常用段常驻内存->内存固定区，不常用段，调用时装入->内存覆盖区,现在不用了，对系统不透明  
覆盖区有若干个，不可能同时访问的程序段共享一个覆盖区
### 交换技术
内存紧张时，将某些进程换出外存，把外存中具备运行条件的进程换入内存（中级调度）PCB不动，  
暂时换出外存等待的进程状态称为挂起态：- 就绪挂起- 阻塞挂起
1. 换出后放在外存的什么位置
![Alt text](OS/images/image-12.png)
对换区I/O>文件区
1. 什么时候交换
 进程运行缺页率
1. 换出哪些进程
优先换出阻塞进程，替换算法
### 虚拟存储
#### 定义
具有**请求调入**和**置换**功能，从逻辑上堆内存容量加以扩充的存储器系统
#### 特征
- 多次性
- 对换性
- 虚拟性
#### 存储管理方式(请求分页,请求分段不考？？)
1. 若当前访问信息不在内存，需要将所需信息**请求调入**内存
2. 内存空间不够，负责将用不到的信息**置换**到外存
3. 前进程的page table，既然页表是逻辑地址到物理地址的映射，每个进程逻辑地址，那就要多张页表
##### 硬件
###### 请求页表机制  
![Alt text](OS/images/image-19.png)  
###### 请求中断机构  
页面不存在，产生缺页中断，进程阻塞，放入阻塞队列，完成后唤醒，放回就绪队列
###### 地址变换机构

##### 页面分配策略（算法不要求？）
###### 最小物理块：能保证程序正常运行的最小物理块数 
###### 驻留集：**请求分页管理**中给进程分配的物理块的集合
###### 局部置换：发生缺页时选择内部的物理块替换
###### 全局置换：请求OS空闲块或替换其他进程物理块
###### 固定分配+局部置换
###### 可变分配+全局置换
###### 可变分配+局部置换
频繁缺页系统送物理块，缺页率特别低系统减物理块，但是缺页时只能选择内部物理块替换
##### 页面调入策略
###### 何时调入——预调页（首次调入），请求调页  
###### 何处调入——对换区，若不足，不会被修改的文件从文件区？？UNIX 未运行在文件区，运行换出进入对换区
###### 调入过程：**背诵**
##### 页面置换算法
###### 缺页率
$$
访问页面成功S，访问页面失败F，总访问A=S+F\\
缺页率f=\frac{F}{A}\\
缺页中断处理时间，页面被修改概率\beta,处理时间t_a,未被修改处理时间t_b\\
t=\beta\times t_a+(1-\beta)\times t_b
$$
###### 最佳置换算法OPT
淘汰以后最长时间不使用，但是程序无法预知，故无法实现，只能作为评价算法
###### 先进先出FIFO
选择驻留时间最久的出——queue
Belady异常——物理块增，缺页率不减反增
###### 最近最久未使用LRU
硬件支持，得修改维护页面信息位吧，对主存-辅存结构开销过大？？
移位寄存器\栈 **编程实现**
###### ~~时钟置换算法CLOCK~~
简单CLOCK算法

```
if 1 ：
    1->0
else
    置换
```
**循环队列**    
![Alt text](image-20.png)   
改进CLOCK算法
```
search：(0,0)
search：(0,1);(1->0,x)
search:(0,0) origin(1,0)
search:(0,1) origin(1,1)
```
优先淘汰未修改的页
##### 工作间和抖动
###### 进程抖动thrashing：刚刚换出的页面马上又换入内存
原因：进程太多，每个进程物理块太少，不满足程序运行要求  
预防：采取局部置换 ，工作集融入处理机调度，L=S准则，选择暂停进程（减少进程数量）
###### 工作集：进程在**某段时间间隔**内，进程实际访问页面的集合  
$$
w(t,\Delta)
$$
窗口尺寸（划分时间）：??
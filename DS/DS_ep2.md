# 栈和队列stack&queue
## stack
>考点：栈容量(简单)  
技巧：simulation

input：abcdefg   
output：bdcfeag

|  |  |  |  |
|---|---|---|---|
|  | ~~d~~ | ~~f~~ |  |
| ~~b~~ | ~~c~~ | ~~e~~ |  |
| a | a | ~~a~~ | ~~g~~ |

>考点：出栈组合类型

#### 无约束型
卡特兰数  
设有n 个不同的元素进栈，则出栈的顺序有
$$
\frac{1}{n+1} C_{2n}^n
$$
#### 约束型
TODO 具体问题具体分析  
### 考点：出栈顺序
这里有一规律可记  
任何出栈的元素后面出栈的元素必须满足以下三点：  
1、在原序列中相对位置比它小的，必须是逆序；  
2、在原序列中相对位置比它大的，顺序没有要求；  
3、以上两点可以间插进行。  

**技巧**：左向右依次选取元素，执行判断：在它`右侧`且`index`比它小的元素是否`逆序`

## queue
### 顺序队列
>考点：假溢出现象

判空：front=rear
### 双端队列
#### 考点1：输出是否合法  
### 循环队列
出栈：front=(front+1)%m  
入栈：rear=(rear+1)%m  

考点2：判满判空条件

技巧：从逻辑定义角度出发，不考虑定义的维护问题
故若rear=队尾的时候，empty它指向哪里？？
| front | rear | 判空 | 判满 |
|---|---|---|---|
| 队头=0 | 队尾=n-1 | front=rear+1 | (rear+2)%m=front |
| 队头=0 | 队尾+1=0 | front=rear | (rear+1)%m=front |
## 应用
### 括号匹配[栈]
### 表达式求值[栈]
#### 将中缀表达式转成后缀表达式  
后缀表达式(逆波兰式)
特点：字符顺序输出，op按计算顺序输出  
`由于计算顺序不唯一，导致后缀表达式不唯一`  
思路：`数字和变量直接输出，符号入栈再出栈`  
数据结构：优先级表【二维数组】+栈  
1.按序+op  
2.将优先级高的弹出  
#### 利用栈计算简单后缀表达式
思路：假设均是二元运算符，取符号与op结合，结果压栈保存
数据结构：字符栈，op栈

### 多维数组的存储和矩阵的压缩存储
对称矩阵
三角矩阵
三对角矩阵
。。。

稀疏矩阵
采用struct i j data 
稀疏矩阵压缩存储会导数访问效率变慢其他三种倒是不会

### 层次遍历[队列]